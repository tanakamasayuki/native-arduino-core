name=Native Arduino Core
version=1.0.0

# Minimal, spec-compliant platform.txt following Arduino CLI platform specification
# Single-line key=value entries. Adjust flags or tools if you need custom toolchain.

# Tool commands
compiler.path=
compiler.c.cmd=gcc
compiler.cpp.cmd=g++
compiler.ar.cmd=ar
compiler.objcopy.cmd=objcopy
compiler.size.cmd=size

# (No upload.tool.default) Upload should be handled by recipe.upload.pattern; avoid tools.* usage in boards.

# Compiler and linker flags
compiler.c.flags=-std=gnu11 -O2 -Wall -ffunction-sections -fdata-sections
compiler.cxx.flags=-std=gnu++11 -O2 -Wall -ffunction-sections -fdata-sections
compiler.ldflags=-Wl,--gc-sections

# Compile C source to object (add include paths for core and sketch)
recipe.c.o.pattern={compiler.path}{compiler.c.cmd} {compiler.c.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o {object_file} {source_file}

# Compile C++ source to object
recipe.cpp.o.pattern={compiler.path}{compiler.cpp.cmd} {compiler.cxx.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o {object_file} {source_file}

# Create static archive from objects
# Ensure archive exists at both {build.path}/{archive_file} and {build.path}/core/<basename>
# to be compatible with different CLI/tool behaviours that expect either path.
recipe.ar.pattern=sh -c '{compiler.path}{compiler.ar.cmd} rcs {build.path}/{archive_file} {object_file} && mkdir -p {build.path}/core && cp -f {build.path}/{archive_file} {build.path}/core/{archive_file}'

# Link objects into a native executable
# Link objects and core archive into a native executable.
# Use the core archive and all object files so the linker produces the final .out
# Link (C) and then run the produced binary.
# We wrap the link in sh -c so we can run the produced .out immediately after linking.
# Link (C) and then run the produced binary.
# We wrap the link in sh -c so we can run the produced .out immediately after linking.
recipe.c.link.pattern={compiler.path}{compiler.cpp.cmd} {compiler.ldflags} {build.path}/{archive_file} {object_files} -o {build.path}/{build.project_name}.out
# Ensure both C and C++ link recipes exist. Some CLI versions call the C++ link recipe
# when linking C++ sketches, so provide an identical cpp variant.

# Link (C++) and then run the produced binary.
recipe.cpp.link.pattern={compiler.path}{compiler.cpp.cmd} {compiler.ldflags} {build.path}/{archive_file} {object_files} -o {build.path}/{build.project_name}.out

# ELF/linker (combine) settings
# Some Arduino CLI/toolchains call a "combine" recipe to merge objects and archives
# into the final ELF; provide a combine pattern that uses --start-group/--end-group
# to ensure all libs are searched. We map compiler.c.elf.cmd to the C++ compiler by default.
compiler.c.elf.cmd={compiler.cpp.cmd}
compiler.c.elf.flags={compiler.cxx.flags}

# Combine (link) pattern: combine all object files and the core archive into the final executable.
# Using start-group/end-group helps resolve circular deps between archives and objects.
recipe.c.combine.pattern={compiler.path}{compiler.c.elf.cmd} {compiler.c.elf.flags} {compiler.ldflags} -Wl,--start-group {object_files} {build.path}/{archive_file} -Wl,--end-group -o {build.path}/{build.project_name}.out
recipe.cpp.combine.pattern={compiler.path}{compiler.c.elf.cmd} {compiler.c.elf.flags} {compiler.ldflags} -Wl,--start-group {object_files} {build.path}/{archive_file} -Wl,--end-group -o {build.path}/{build.project_name}.out

# Upload recipe: execute the produced binary locally
recipe.upload.pattern=sh -c 'chmod +x "{build.path}/{build.project_name}.out" 2>/dev/null || true; "{build.path}/{build.project_name}.out"'

# Size command
recipe.size.pattern={compiler.path}{compiler.size.cmd} {build.path}/{build.project_name}.out

# Core name
compiler.core=core
build.core=native
