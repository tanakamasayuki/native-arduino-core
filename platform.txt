name=Native Arduino Core
version=1.0.0

# Minimal, spec-compliant platform.txt following Arduino CLI platform specification
# Single-line key=value entries. Adjust flags or tools if you need custom toolchain.

# Tool commands
compiler.path=
compiler.c.cmd=gcc
compiler.cpp.cmd=g++
compiler.ar.cmd=ar
compiler.objcopy.cmd=objcopy
compiler.size.cmd=size

# Compiler and linker flags
compiler.c.flags=-std=gnu11 -O2 -Wall -ffunction-sections -fdata-sections
compiler.cxx.flags=-std=gnu++11 -O2 -Wall -ffunction-sections -fdata-sections
compiler.ldflags=-Wl,--gc-sections

# Compile C source to object (add include paths for core and sketch)
recipe.c.o.pattern={compiler.path}{compiler.c.cmd} {compiler.c.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o {object_file} {source_file}

# Compile C++ source to object
recipe.cpp.o.pattern={compiler.path}{compiler.cpp.cmd} {compiler.cxx.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o {object_file} {source_file}

# Create static archive from objects
recipe.ar.pattern={compiler.path}{compiler.ar.cmd} rcs {build.path}/{archive_file} {object_file}

# Link objects into a native executable
recipe.c.link.pattern={compiler.path}{compiler.cpp.cmd} {compiler.ldflags} {object_file} -o {build.path}/{build.project_name}.out

# Upload recipe: execute the produced binary locally
recipe.upload.pattern=sh -c "{build.path}/{build.project_name}.out"

# Size command
recipe.size.pattern={compiler.path}{compiler.size.cmd} {build.path}/{build.project_name}.out

# Core name
compiler.core=core
build.core=native
