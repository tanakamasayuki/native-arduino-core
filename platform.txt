name=Native Arduino Core
version=1.0.0

# Compiler tool commands (use system gcc/g++)
compiler.path=
compiler.c.cmd=gcc
compiler.cpp.cmd=g++
compiler.ar.cmd=ar
compiler.objcopy.cmd=objcopy

compiler.c.flags=-std=gnu11 -O2 -Wall
compiler.cxx.flags=-std=gnu++11 -O2 -Wall
compiler.ldflags=

# Compile C source to object
## Compile C source to object
## Add include paths for the core and the sketch so Arduino CLI can find Arduino.h
recipe.c.o.pattern=sh -lc 'OUT="{build.path}/{object_file}"; if [ -z "{object_file}" ] || [ -d "$OUT" ] || [ "${OUT: -1}" = "/" ]; then mkdir -p "{build.path}/tmp"; OUT="{build.path}/tmp/$(basename "{source_file}").o"; fi; mkdir -p "$(dirname "$OUT")"; {compiler.path}{compiler.c.cmd} {compiler.c.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o "$OUT" "{source_file}"'
## Compile C++ source to object
recipe.cpp.o.pattern=sh -lc 'OUT="{build.path}/{object_file}"; if [ -z "{object_file}" ] || [ -d "$OUT" ] || [ "${OUT: -1}" = "/" ]; then mkdir -p "{build.path}/tmp"; OUT="{build.path}/tmp/$(basename "{source_file}").o"; fi; mkdir -p "$(dirname "$OUT")"; {compiler.path}{compiler.cpp.cmd} {compiler.cxx.flags} -I{runtime.platform.path}/cores/{build.core} -I{build.path}/sketch -c -o "$OUT" "{source_file}"'
# Link objects into a native executable
recipe.c.link.pattern={compiler.path}{compiler.cpp.cmd} {compiler.ldflags} {object_files} -o {build.path}/{build.project_name}.out

# Upload recipe: execute the produced binary locally
recipe.upload.pattern=sh -c "{build.path}/{build.project_name}.out"

# Size (noop)
recipe.size.pattern=echo "size not applicable"

# Core name
compiler.core=core
build.core=native
